{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hi","text":"<p>The Documents here were originally made for the Rodev's Helper Docs but since its been shut down they are now here</p>"},{"location":"#discord-servers-you-can-join-to-get-help","title":"Discord servers you can join to get help","text":"<p>https://discord.gg/rodevs</p> <p>https://discord.gg/hd</p>"},{"location":"Basic%20Methods%20of%20Instances/","title":"Basic Methods of Instances","text":""},{"location":"Basic%20Methods%20of%20Instances/#addtagtag-string-void","title":"AddTag(tag: string): void","text":"<p>This method adds a tag to the instance which can be used by CollectionService using CollectionService:GetAllTags(). This method also invokes CollectionService:GetInstanceAddedSignal().</p> <pre><code>local cs = game:GetService(\"CollectionService\") \nlocal part = Instance.new(\"Part\",workspace) \npart:AddTag(\"MyTag\") \nprint(part:HasTag(\"MyTag\")) --&gt; true\nprint(cs:GetTagged(\"MyTag\")) --&gt; {Part}\n</code></pre>"},{"location":"Basic%20Methods%20of%20Instances/#hastagtag-string-boolean","title":"HasTag(tag: string): boolean","text":"<p>returns true/false if the instance has the give tag</p>"},{"location":"Basic%20Methods%20of%20Instances/#removetagtag-string-void","title":"RemoveTag(tag: string): void","text":"<p>This method removes the a tag set to the instance.</p>"},{"location":"Basic%20Methods%20of%20Instances/#clone-instance","title":"Clone(): Instance","text":"<p>Creates a Copy of the Instance and its Children. The Parent of the cloned Instance will be set to nil. </p>"},{"location":"Basic%20Methods%20of%20Instances/#destroy-void","title":"Destroy(): void","text":"<p>Sets the Parent property to nil, but unlike the Remove() method, Destroy() locks the parent and disconnects all connections. This will also call the Destroy methods of the children as well.</p> <p>Info</p> <p>Locking the parent means that the object cannot be reused and if you try to re-set the parent you will get the error:  The Parent property of [Instance] is locked, current parent: NULL, new parent [Instance]  .</p>"},{"location":"Basic%20Methods%20of%20Instances/#waitforchildchildname-string-timeout-number-instance","title":"WaitForChild(childName: String, timeOut: number): Instance","text":"<p>Returns the child of the Instance with the given name. If the child does not exist it will yield the code for the duration of timeOut (if not given default to 5) or until it exist. If timeOut is reached and the child still does not exist, if will send an warning:  Infinite yield possible on: [line]  .</p>"},{"location":"Basic%20Methods%20of%20Instances/#findfirstchildname-string-recursive-boolean-instance","title":"FindFirstChild(name: string, recursive: boolean): Instance","text":"<p>This will return the first child with the given name, if no child with the name is found then it will return nil. If given a 2<sup>nd</sup> argument is true then it will check the children of the children... aka the descendants. </p> <pre><code>local part1 = Instance.new(\"Part\")\nlocal part2 = Instance.new(\"Part\",part1)\npart2.Name = \"Part2\"\nlocal part3 = Instance.new(\"Part\",part2)\npart3.Name = \"Part3\"\nprint(part1:FindFirstChild(\"Part2\")) --&gt; Part2, Part2 is a child of part1\nprint(part1:FindFirstChild(\"Part3\")) --&gt; nil, Part is not a child of part1\nprint(part1:FindFirstChild(\"Part3\",true)) --&gt; Part3, this returns Part3 because we told it to find the descendants of the part as well \n</code></pre> <p>Info</p> <p>WaitForChild is used when you are not sure if a child exists such as when replicating  stuff</p>"},{"location":"Basic%20Methods%20of%20Instances/#findfirstancestorname-string-instance","title":"FindFirstAncestor(name: string): Instance","text":"<p>This will return the first ancestor(parent of the parent of the parent...) with the given name. If no ancestor with the name is found then return nil.</p> <pre><code>local part1 = Instance.new(\"Part\")\npart1.Name = \"ParentPart\"\nlocal part2 = Instance.new(\"Part\",part1)\npart2.Name = \"ChildPart\"\nlocal part3 = Instance.new(\"Part\",part2)\npart3.Name = \"SubChildPart\"\n\nprint(part3:FindFirstAncestor(\"ChildPart\")) --&gt; ChildPart\nprint(part3:FindFirstAncestor(\"ParentPart\")) --&gt; ParentPart\nprint(part3:FindFirstAncestor(\"Parent\")) --&gt; nil, part3 has no ancestor is named Parent \n</code></pre>"},{"location":"Basic%20Methods%20of%20Instances/#setattributeattribute-string-value-variant-void","title":"SetAttribute(attribute: string, value: Variant): void","text":"<p>Sets the given attribute to the given value. If value is nil then the Attribute will be removed.</p> <pre><code>local part = Instance.new(\"Part\") \npart:SetAttribute(\"Health\",20) \nprint(part:GetAttribute(\"Health\")) --&gt; 20\n</code></pre> <p>Warning</p> <p>Naming requirements and restrictions:</p> <ul> <li>Names must only use alphanumeric characters and underscore</li> <li>No spaces or unique symbols are allowed</li> <li>Strings must be 100 characters or less</li> <li>Names are not allowed to start with RBX unless the caller is a Roblox core-script (reserved for Roblox)</li> </ul>"},{"location":"Basic%20Methods%20of%20Instances/#getattributeattribute-string-variant","title":"GetAttribute(attribute: string): Variant","text":"<p>This will return the value stored in the given attributes, nil if the attribute does not exist </p>"},{"location":"Basic%20Methods%20of%20Instances/#getchildren-objects","title":"GetChildren(): Objects","text":"<p>Returns and array of all the children under the Instance. </p>"},{"location":"Basic%20Methods%20of%20Instances/#getdescendants-objects","title":"GetDescendants: Objects","text":"<p>Similar to GetChildren() but returns an array with the Children of the Children of the Children as well.</p>"},{"location":"Basic%20Methods%20of%20Instances/#getpropertychangedsignalproperty-string-rbxscriptsignal","title":"GetPropertyChangedSignal(property: string): RBXScriptSignal","text":"<p>Returns an event which fires when the given property is modified</p> <p>Warning</p> <p>GetPropertyChangedSignal will not fire if the Property being changed is being updated via Physics. Ex: trying to detect if a Player moved by doing GetPropertyChangedSignal(\"Position\"). This will not fire when the player moves because the player is moved using Physics.</p>"},{"location":"Basic%20Methods%20of%20Instances/#isaclassname-stringboolean","title":"IsA(className: string):boolean","text":"<p>Returns true if the Instance class matches or is a sub-class of the given class</p> <pre><code>local part = Instance.new(\"Part\")\nprint(part:IsA(\"Part\")) --&gt; true, Part is a Part\nprint(part:IsA(\"BasePart\")) --&gt; true, Part is a sub-class of BasePart\nprint(part:IsA(\"Model\")) --&gt; false, part is not a model  \n</code></pre>"},{"location":"Fixing%20Errors/","title":"Fixing Errors","text":"<p>This section will go over some basics on how to fix or find errors</p>"},{"location":"Fixing%20Errors/#checking-output","title":"Checking Output","text":"<p>Usually, if your code doesn't run then it might be because there was an error in your code. Which you can check by going to output.</p> <p>To open output you go to View -&gt; Output</p> <p></p> <p>Info</p> <p>Another useful tool is the Script Analysis, what it does is show warnings/errors  (mainly syntax related) while you are editing the script. It is directly below the Output</p> <p>To see if there is an error you will see a message that is red like this one</p> <p></p> <p>You can click on the error and it will bring you to the line and script that it errored on </p> <p>If clicking on it doesn't lead you anywhere and you see this </p> <p> it means that the script it errored in was deleted. Which usually means it was a local script or a cloned script. What you can do is click on the error while in the game instead of after stopping and it should lead you to the right script.</p>"},{"location":"Fixing%20Errors/#reading-errors-messages","title":"Reading errors messages","text":"<ul> <li>Time of message:  When did it error</li> <li>Script Location:  What script did it error on and where is the script</li> <li>Line the error is on:  What line did it error on</li> <li>Error Message:  What is the error</li> <li>Environment:  is the error on the server, client, or studio</li> </ul> <p>You mainly only need to focus on the Script Location, error line, and the error itself. If it's an error you don't understand you can use Google to search for the error message. There is a section below explaining how to do that.</p> Common Error Messages"},{"location":"Fixing%20Errors/#name-is-not-a-valid-member-of-object","title":"[name] is not a valid member of object","text":"<p>This error shows up when you try to get a child that does not exist in the object, Usually if its to do with the client you can use WaitForChild but if that doesn't work, check your code and make sure the child exists.  </p>"},{"location":"Fixing%20Errors/#attempt-to-perform-arithmeticarithmetic-on-number-and-type","title":"attempt to perform arithmetic(arithmetic) on number and [type]","text":"<p>This means you are trying to do arithmetic on a number and a type you can not do arithmetic on.  The only objects you can do arithmetic on are numbers, strings, and objects that have arithmetic metamethods (__mul,__add...)</p> <p>Info</p> <p>This also applies to  attempt to compare something &lt; number  and  attempt to concatenate string with something . They either must be types that be compared on concatenated or have the metatmethods that allow them to do it</p>"},{"location":"Fixing%20Errors/#argument-number-missing-or-nil","title":"Argument [number] missing or nil","text":"<p>This means that one of the arguments you sent is nil or empty. arguments are the data you are sending ex. <pre><code>local function f(x) -- x is a parameter\n    ...\nend\nf(y) -- y is an argument\n</code></pre> to fix this make sure that the argument is being defined correctly or is the right type</p>"},{"location":"Fixing%20Errors/#unable-to-cast-value-to-object","title":"Unable to cast value to Object","text":"<p>this means that the value you are trying to send cannot be converted into the object the function wants. To fix this make sure that the data type is the correct one.</p>"},{"location":"Fixing%20Errors/#expected-to-close-at-column-number-got-eof","title":"Expected ')' (to close '(' at column [number]), got eof","text":"<p>This is a syntax error. it means that you either have extra parentheses or lack one. To fix this look for where the lines are underlined in red as roblox catches syntax errors before the game is being run.</p>"},{"location":"Fixing%20Errors/#print-debugging","title":"Print Debugging","text":"<p>Print debugging mainly consists of adding print statements to find out what is wrong this is mainly used if no errors are showing up in the output</p>"},{"location":"Fixing%20Errors/#use-case","title":"use case","text":"<p>let's say we have a script set up like this <pre><code>local x = getX()\nlocal y = getY()\nif x &gt;= 3 then\n    if y == 0 then\n        doSomething()\n    end\nend\n</code></pre> and for some reason doSomething() is not being invoked, instead of going to scripting help and asking why the doSomething isn't working here is what you can do.</p>"},{"location":"Fixing%20Errors/#1-print-before-an-if-statement","title":"1. Print before an if statement","text":"<p><pre><code>local x = getX()\nlocal y = getY()\nprint(\"script is running\")\nif x &gt;= 3 then\n   print(\"x check passed\")\n    if y == 0 then\n       print(\"y check passed\")\n        doSomething()\n    end\nend\n</code></pre> When you run the script and you only see  <pre><code>script is running\nx check passed\n</code></pre> Then you will know that y is not equal to 0</p> <p>Note</p> <p>You don't really need to add all those prints to figure out what's wrong for example if you know your code is running you can probably remove the print(\"script is running\"). You also can just print(\"X\") (or anything that will help) instead of print(\"x check passed\")</p>"},{"location":"Fixing%20Errors/#2-printing-the-variables","title":"2. Printing the variables","text":"<p><pre><code>local x = getX()\nlocal y = getY()\nprint(x)\nif x &gt;= 3 then\n    print(y)\n    if y == 0 then\n        doSomething()\n    end\nend\n</code></pre> <pre><code>4\n4\n</code></pre> From this, you can tell that y is 4 not 0 so from this you would most likely look into how y is being assigned which in this case can tell us that something must be wrong with the getY function </p>"},{"location":"Fixing%20Errors/#visualize-debugging","title":"visualize debugging","text":"<p>This type of debugging can be using parts or other methods to visualize the problem this can be used if using prints doesn't really tell you what's wrong </p>"},{"location":"Fixing%20Errors/#use-case_1","title":"use case","text":"<p>Let's say we are doing some raycasting but the ray isn't hitting anything  <pre><code>local green = workspace.PartA\nlocal red = workspace.PartB\nlocal direction = (green.Position-red.Position).Unit*20\n\nlocal ray = workspace:Raycast(green.Position,direction)\nprint(ray)\nprint(direction)\n</code></pre></p> <p> <pre><code>nil\n600.8695068359375, -531.7534790039062, -596.8199462890625\n</code></pre></p> <p>For beginners, you might not see anything wrong with the script and looking at what direction is doesn't really help, so what you can do here is create a part that goes in that ray direction like this</p> <pre><code>local green = workspace.PartA\nlocal red = workspace.PartB\nlocal direction = (green.Position-red.Position).Unit*20\n\nlocal ray = workspace:Raycast(green.Position,direction)\nprint(ray)\n\nlocal dir = Instance.new('Part')\ndir.Size = Vector3.new(.2,.2,20)\ndir.CFrame = CFrame.lookAt(green.Position+direction/2,green.Position + direction)\ndir.Anchored = true\ndir.Parent = workspace\n</code></pre> <p> From this we can see that direction is indeed wrong and when we look at how direction is defined we can see that we did (start-goal) when the proper way is (goal - start)</p> <p>So fixing that and running the code will now give the correct results <pre><code>local green = workspace.PartA\nlocal red = workspace.PartB\nlocal direction = (red.Position-green.Position).Unit*20\n\nlocal ray = workspace:Raycast(green.Position,direction)\nprint(ray)\n\nlocal dir = Instance.new('Part')\ndir.Size = Vector3.new(.2,.2,20)\ndir.CFrame = CFrame.lookAt(green.Position+direction/2,green.Position + direction)\ndir.Anchored = true\ndir.Parent = workspace\n</code></pre> <pre><code>RaycastResult{PartB @ -4.82407379, 11.2030563, 18.3839722; normal = 0, 0, -1; material = Plastic} \n</code></pre></p> <p></p>"},{"location":"Fixing%20Errors/#making-your-code-more-readable-remaking-it","title":"Making your code more readable/ Remaking it","text":"<p>Sometimes making your code more readable will help with debugging  ex: given this script it might be a bit annoying to figure out what wrong </p> <p><pre><code>--GOAL: to make the ProximityPrompt enabled set to true if both the flags for\n-- randomTor and LocalTorso is false, otherwise true\nif RandomTor:FindFirstChild(\"Flag\").Value == false then\n    if LocalTorso:FindFirstChild(\"Flag\").Value == false then\n        RandomTor:FindFirstChild(\"ProximityPrompt\").Enabled = true\n    else\n        RandomTor:FindFirstChild(\"ProximityPrompt\").Enabled = false\n    end\nend\n</code></pre> What we can do is use variables to make it cleaner <pre><code>local randomFlag = RandomTor:FindFirstChild(\"Flag\")\nlocal LocalFlag = LocalTorso:FindFirstChild(\"Flag\")\nlocal RandomProx = RandomTor:FindFirstChild(\"ProximityPrompt\")\nif not randomFlag.Value then\n    if not LocalFlag.Value then\n       RandomProx.Enabled = true\n    else\n       RandomProx.Enabled = false\n    end\nend\n</code></pre> If you still don't see what's wrong with it what you can do is just plug values into it and think what the expected results are. The reason this isn't working is because it ignores when randomFlag.Value is true so to fix this we can do: <pre><code>local randomFlag = RandomTor:FindFirstChild(\"Flag\")\nlocal LocalFlag = LocalTorso:FindFirstChild(\"Flag\")\nlocal RandomProx = RandomTor:FindFirstChild(\"ProximityPrompt\")\nif (not randomFlag.Value) and (not LocalFlag.Value) then \n    RandomProx.Enabled = true\nelse\n    RandomProx.Enabled = false\nend\n</code></pre></p> <p>Info</p> <p>For people that really care how much lines their code has you can do <pre><code>local randomFlag = RandomTor:FindFirstChild(\"Flag\")\nlocal LocalFlag = LocalTorso:FindFirstChild(\"Flag\")\nlocal RandomProx = RandomTor:FindFirstChild(\"ProximityPrompt\")\nRandomProx.Enabled =  not (randomFlag.Value or LocalFlag.Value)\n</code></pre> as the condition is just a boolean </p>"},{"location":"Fixing%20Errors/#using-google","title":"Using google","text":"<p>When you get an error message that you don't know or understand, what you can do is go to google.com and search for the error message. Usually, you will find a devform post that has the same error and the solution. Another way to help enhance the search is by using \"\". This tells google to look for that keyword. Sometimes you might not get the results you're looking for, for example, this error</p> <p></p> <p>and when we do a Google search we don't get anything that relates to that</p> <p></p> <p>So what we can do here is maybe change the wording or adding roblox into the search to help Google search better</p> <p></p> <p>and there we go.</p>"},{"location":"Fixing%20Errors/#using-roblox-debugger","title":"Using roblox debugger","text":"<p>Another way of debugging is using tools roblox provided such as breakpoints, watch, and call stack. But most of the time you won't really be needing this. but if you want you can find out how to use them here.</p>"},{"location":"Fixing%20Errors/#common-mistakes","title":"Common mistakes","text":"<p>This section is just a list of common mistakes people tend to do</p>"},{"location":"Fixing%20Errors/#1-using-starter-gui-instead-of-playergui","title":"1. Using starter Gui instead of playergui","text":""},{"location":"Fixing%20Errors/#startergui","title":"StarterGui","text":"<p>StarterGui is a container that is under Game. Its purpose is to act like a container to hold your guis before they are cloned into the PlayerGui. When a player joins roblox will take everything that is currently in StarterGui and clone them into the players PlayerGui. https://create.roblox.com/docs/reference/engine/classes/StarterGui</p> <p>So given a script like the one below, it will not make ScreenGui visible because it is modifying a ScreenGui in StarterGui</p> <pre><code> --LocalScript\nlocal StarterGui = game.StarterGui \nlocal ScreenGui = StarterGui:WaitForChild(\"ScreenGui\")\nScreenGui.Enabled = true --!! THIS WILL NOT WORK !!\n</code></pre>"},{"location":"Fixing%20Errors/#playergui","title":"PlayerGui","text":"<p>PlayerGui is a container that is under the player that joined. Each player will have their own PlayerGui which other players will not be able to see. The server will be able to see it but its is not recommended to let the server modify anything in PlayerGui. PlayerGui is what the client actually sees. https://create.roblox.com/docs/reference/engine/classes/PlayerGui</p> <p></p> <p>so to fix the given script above we can do this</p> <pre><code>--LocalScript\nlocal player = game.Players\nlocal LocalPlayer = player.LocalPlayer\nlocal PlayerGui = LocalPlayer.PlayerGui\nlocal ScreenGui = PlayerGui:WaitForChild(\"ScreenGui\")\nScreenGui.Enabled = true \n</code></pre>"},{"location":"Fixing%20Errors/#2-localscripts-in-the-wrong-places","title":"2. LocalScripts in the wrong places","text":"<p>Another common mistake is having LocalScripts in the wrong place such as having a LocalScript in ServerScriptService. LocalScripts run in a client environment such as StarterPlayerScripts, ServerScriptService is on the server</p> <p></p> <p>https://create.roblox.com/docs/reference/engine/classes/LocalScript</p>"},{"location":"Fixing%20Errors/#3-trying-to-access-serverstorage-from-the-client","title":"3. Trying to access ServerStorage from the client","text":"<p>ServerStorage is a Storage for the server to see not the client. If you want to store something store it in ReplicatedStorage</p>"},{"location":"Fixing%20Errors/#4-indirect-change","title":"4. Indirect Change","text":"<p>Indirect Change is when you are changing the variable, not the actual value, for example:</p> <p><pre><code>local t = {}\nt.Value = 1\nlocal value = t.Value\nvalue = 5\nprint(t.Value) --&gt; 1\nprint(value) --&gt;5\n\n--another example:\n\nlocal part = workspace.Part\nlocal position = part.Position\n\nposition = Vector3.new(1,2,3)\n-- this is wrong\n</code></pre> The example above is wrong because you are not changing the values but instead the variable.</p> <p>the proper way to do this is to do: <pre><code>local t = {}\nt.Value = 1\nt.Value = 5\nprint(t.Value) --&gt; 5\n\n--another example:\n\nlocal part = workspace.Part\npart.Position = Vector3.new(1,2,3)\n</code></pre></p>"},{"location":"Fixing%20Errors/#5-not-having-a-bindtoclose-in-their-datastoresaving-script","title":"5. Not having a BindToClose in their DataStoreSaving script","text":"<p>A very common mistake people tend to make is not having a BindToClose in their Datastore script</p> <p>Here is an example script: <pre><code>local dss =game:GetService(\"DataStoreService\")\nlocal MyDs = dss:GetDataStore(\"MyStore\")\n\nlocal function save(player)\n    MyDs:SetAsync(player.UserId,\"your data\")\nend\n\ngame.Players.PlayerRemoving(save)\n</code></pre> This will work, but will only work sometimes, this is because when the last person leaves roblox doesn't care if a script is still running or not. To fix this you can use a BindToClose. What a BindToClose does is it forces roblox's server or studio to wait until the function inside of it is done running (30 seconds max) then tell the server to close.</p> <p>Heres is how we can implement it: <pre><code>local dss =game:GetService(\"DataStoreService\")\nlocal MyDs = dss:GetDataStore(\"MyStore\")\n\nlocal function save(player)\n    MyDs:SetAsync(player.UserId,\"your data\")\nend\n\ngame.Players.PlayerRemoving(save)\n\ngame:BindToClose(function()\n    for _,Player in game.Players:GetPlayers() do\n        save(Player)\n    end\nend)\n</code></pre></p> Warning <p>Another mistake people tend to do is using spawn/task.spawn inside of the BindToClose <pre><code>game:BindToClose(function()\n    for _,Player in game.Players:GetPlayers() do\n        task.spawn(save,Player)\n    end\nend)\n</code></pre> this is wrong because task.spawn makes it so that the saving process doesn't yield, but we need it to yield. If you want to do it correctly you can do it like this <pre><code>game:BindToClose(function()\n    local players = game.Players:GetPlayers()\n    local amt = #players -- how many players need to be saved\n    local count = 0 -- how many players have been saved\n    for _,Player in players do\n        task.spawn(function() \n        -- makes it so that everyone saves at the same time instead of 1 by 1\n            save(Player)\n            count += 1\n            -- when player is done saving increase\n        end)\n    end\n    repeat task.wait() until count == amt -- yields until everything is done\nend)\n</code></pre> or if you want to be fancy <pre><code>game:BindToClose(function()\n    local players = game.Players:GetPlayers()\n    local thread = coroutine.running() --gets current thread\n    local amt = #players -- how many players needs to be saved\n    local count = 0 -- how many players has been saved\n    for _,Player in players do\n        task.spawn(function()\n        -- makes it so that everyone save at the same time instead of 1 by 1\n            save(Player)\n            count += 1\n            -- When player is done saving increase\n            if count == amt then\n                coroutine.resume(thread)\n                -- if it's the last player, resume the thread\n            end\n        end)\n    end\n    if count == amt then return end -- if everyone's data has already been saved there is no need to yield\n    coroutine.yield() -- yields the thread\nend)\n</code></pre></p>"},{"location":"Fixing%20Errors/#6-animations-working-in-studio-but-not-in-game","title":"6. Animations working in Studio but not In game","text":"<p>Animations only work if the game the animation is owned is the same to fix it you will have to upload the animation to the same game owner or group </p> <p> (The green is what will happen)</p>"},{"location":"Fixing%20Errors/#conclusion","title":"Conclusion","text":"<p>Hope this helps if you have any more questions you can ask in scripting-help. Anyways Good luck out there and don't get joe tagged.</p> <p></p>"},{"location":"Inheritance/","title":"Inheritance","text":""},{"location":"Inheritance/#pre-requisites","title":"Pre-requisites","text":"<p>Before reading this tutorial, you should know about metatables. An explanation of metatables exists in the Lua-Learning folder (not anymore).</p>"},{"location":"Inheritance/#what-is-inheritance","title":"What is Inheritance?","text":"<p>Inheritance is used mainly in oop based languages that allow one class to inherit the properties and methods from another class. </p> <p>*do note that there are a few ways of doing inheritance in lua(u) and this is one of them</p>"},{"location":"Inheritance/#setting-up-inheritance","title":"Setting up Inheritance","text":"<p>Let\u2019s say we have a class called Person Class that is set up like this</p> <p><pre><code>local Person = {}\n\nPerson.__index = Person\n\nfunction Person.new(Name,Age,Balance)\n   return setmetatable({Name = Name,Age = Age, Balance = Balance},Person)\nend\n\nfunction Person.__tostring(self)\n    return self.Name\nend\nfunction Person:GetBalance()\n    return '$'..self.Balance\nend\n\nfunction Person:GetAge()\n    return self.Age\nend\n\nfunction Person:GrowUp()\n    self.Age += 1\nend\n\nreturn Person\n</code></pre> Now lets make a Class call Student that will inherit from the Person Class and give it a Method called PayStudentTuition <pre><code>local Student = {}\nlocal Person = require(Path.To.Person.Class)\n\nStudent.__index = setmetatable(Student,Person)\n\nfunction Student.__tostring(self)\n    return \"Student: \"..self.Name\nend\n\nfunction Student.new(Name,Age,Balance,Id)\n    return setmetatable({Name = Name,Age = Age,Balance = Balance,Id = Id},Student)\nend\n--another way you can make the constructor\nfunction Student.new(Name,Age,Balance,Id)\n    local person = Person.new(Name,Age,Balance)\n    person.Id = Id\n    return setmetatable(person,Student)\nend\n\nfunction Student:PayStudentTuition(fees)\n    self.Balance -= fees\nend\n\nreturn Student\n</code></pre> Basically what we've done is modify the __index metamethod so it also checks the Person class if the method you're looking for does not exist in the Student Class</p> <p>For those that are wondering why we need to do it like that and we can't just do this</p> <pre><code>local Student = {}\nlocal Person = require(Path.To.Person.Class)\n\nStudent.__index = Student\n\nfunction Student.new(Name,Age,Balance,Id)\n   return setmetatable(setmetatable({Name = Name,Age = Age,Balance = Balance,Id = Id},Person),Student)\nend\n</code></pre> <p>it's because using setmetatable on a metatable will override the current metatable's metamethods.</p> <p>Now lets make a Class call Teacher that will inherit from the Person Class and give it a Method called GetPaycheck <pre><code>local Teacher = {}\nlocal Person = require(Path.To.Person.Class)\n\nTeacher.__index = setmetatable(Teacher,Person)\n\nfunction Teacher.__tostring(self)\n    return \"Teacher: \"..self.Name\nend\n\nfunction Teacher.new(Name,Age,Balance)\n    return setmetatable({Name = Name,Age = Age,Balance = Balance},Teacher)\nend\n\nfunction Teacher:GetPaycheck(Amt)\n    self.Balance += Amt\nend\n\nreturn Teacher\n</code></pre></p> <p>Here is an example script </p> <pre><code>local StudentClass = require(Path.To.Student.Class)\nlocal PersonClass = require(Path.To.Person.Class)\nlocal TeacherClass = require(Path.To.Teacher.Class)\nlocal Hao = PersonClass.new(\"Hao\",nil,-99999)\nlocal Bob = StudentClass.new(\"Bob\",10,30,1235)\nlocal Smith = TeacherClass.new(\"TeacherClass\",37,200)\n\nBob:GrowUp() -- this is a method in the Person Class\nBob:PayStudentTuition(4000) -- this is a method in the Student Class\nprint(Bob:GetAge()) --&gt; 11 \nprint(Bob:GetBalance()) --&gt; $-3970\nprint(Bob) -- Invokes the __tostring metamethod --&gt; \"Student: Bob\"\n\nSmith:GetPaycheck(100) -- this is a method in the Teacher Class\nprint(Smith:GetBalance()) --&gt; $300\nprint(Smith) --&gt; \"Teacher: Smith\"\n\nprint(Hao) --&gt; \"Hao\"\n</code></pre> <p>Also if you want to inherit from multiple classes you would just keep adding to the __index metamethod </p> <pre><code>local MiddleSchoolStudent = {}\n\nMiddleSchoolStudent.__index = setmetatable(MiddleSchoolStudent,Student)\n-- will first check MiddleSchoolStudent then check Student and lastly it will check Person class if a key dose not exist \n</code></pre>"},{"location":"Inheritance/#thanks-for-reading","title":"Thanks for reading!","text":"<p>Thats pretty much it for this method of inheritance. if you have any more questions you can ask in #scripting-help.</p>"},{"location":"Parallel%20luau/","title":"Parallel luau","text":"<p>Parallel Luau is a way of achieving real multithreading in roblox using the Actor instance.</p> <p>Info</p> <p>Multithreading is a way of running multiple threads at the same time. Base Lua does not have this feature and when you use task.spawn or coroutines it is not really multithreading. The function is still only running on a single thread but Lua makes it so it looks like it is running at the same time</p>"},{"location":"Parallel%20luau/#actors","title":"Actors","text":"<p>Actors is an Instance that allows scripts under that Actor to run in Parallel.</p> <p>Warning</p> <p>The Memory under Actors will not be the same so when you require a module a different table will be returned (if your module returns a table) than in the main Thread. This means you can't use modules to transfer data between Actors.</p> <pre><code>--Script1\nlocal module = require(...)\nmodule.X = 1\nprint(module.X) --&gt; 1\n\n--Script2\nlocal module = require(...)\ntask.wait(1)\nprint(module.X) --&gt; 1\n\n--Script Under Actor\nlocal module = require(...)\ntask.wait(1)\nprint(module.X) --&gt; nil\n</code></pre>"},{"location":"Parallel%20luau/#communicating-between-threads","title":"Communicating Between Threads","text":"<p>There are currently 4 ways to efficiently communicate between threads: Actor Messaging API, Shared Tables, Bindables, or Direct Data Model Communication.</p>"},{"location":"Parallel%20luau/#actor-messaging-api","title":"Actor Messaging API","text":"<p>The Actor Messaging API allows a script to receive data from other actors or the main thread. It currently consists of 3 methods: SendMessage(), BindToMessage(), and BindToMessageParallel().</p>"},{"location":"Parallel%20luau/#sendmessage","title":"SendMessage","text":"<p>Used to Send Messages between threads. The first argument would be the key while the rest will be the data to send <pre><code>local Actor = ...\nworkerActor:SendMessage(\"myKey\", \"hello world\")\n</code></pre></p>"},{"location":"Parallel%20luau/#bindtomessageparallel","title":"BindToMessage(Parallel)","text":"<p>Used to receive data. If BindToMessageParallel was used then run the code in Parallel. The first Parameter is the key while the second Parameter is a callback. <pre><code>local Actor = script:GetActor()\nActor:BindToMessage(\"myKey\", function(data)\n    print(data)\nend)\n\nActor:BindToMessageParallel(\"myKey\", function(data)\n    print(data)\nend)\n</code></pre></p>"},{"location":"Parallel%20luau/#shared-tables","title":"Shared Tables","text":"<p>Shared Table is like a normal table except its contents are shared between threads. This means that if you update a value in one thread, it will also update for other threads. <pre><code>local SharedTableRegistry = game:GetService(\"SharedTableRegistry\")\nlocal SharedTable = SharedTableRegistry:GetSharedTable(\"mySharedTable\")\n--//Parallel Thread\nSharedTable.X = 1\n--//Another Parallel Thread\nprint(SharedTable.X) --&gt; 1\n</code></pre></p> <p>Warning</p> <p>When using SharedTable you could have race conditions that can cause unwanted behaviors. If you want to know more about Thread Safety you can scroll down</p>"},{"location":"Parallel%20luau/#bindables","title":"Bindables","text":"<p>One of the best ways currently (In my Opinion) to send data between threads is using Bindables as they are almost 4x more efficient than SharedTables.</p> <pre><code>--//main Thread\nlocal Actor = ...\nlocal BindableFunction = Actor.Bindable \n-- assuming you have an event/function parented to the Actor\n\nlocal data = BindableFunction:Invoke(\"DoSomething\")\n\n\n--//Actor Script\nlocal Actor = script:GetActor()\nlocal BindableFunction = Actor.Bindable\nBindableFunction.OnInvoke(data)\n    task.desynchronized() -- runs in parallel\n    return doSomething(data)\nend\n</code></pre> <p>Info</p> <p>When Sending/Returning Tables, avoid large dictionaries if you can. If possible try to convert dictionaries into arrays. Another thing is if your array is going to consist of Strings that are showing up more than once you could send/return two tables, the data table, and a key table.</p> <pre><code>--//before\nlocal data = {\n    [1] = \"String1\",\n    [2] = \"String1\",\n    [3] = \"String3\",\n    [4] = \"String2\",\n    [5] = \"String2\",          \n}\nreturn data\n-----------------------------------------\n--//after\nlocal key = {\n   [1] = \"String1\",\n   [2] = \"String2\",\n   [3] = \"String3\",\n}\nlocal data = {\n    [1] = 1,\n    [2] = 1,\n    [3] = 3,\n    [4] = 2,\n    [5] = 2,          \n}\n--to get the value of an index you can do key[valueAtIndex]\nreturn data,key\n--or\nreturn {data,key}\n</code></pre> <p>This is much more efficient then as it's faster to Serialize numbers than it is for strings. And the size of the data being sent over is lower as well. (this can also apply to remotes)</p>"},{"location":"Parallel%20luau/#direct-data-model-communication","title":"Direct Data Model Communication","text":"<p>This type of communication uses the Instances under the game and modifying/reading their properties. However, to maintain thread-safety roblox has systems that disallow threads that are desynchronized to read/write to the Instances.  </p>"},{"location":"Parallel%20luau/#thread-safety","title":"Thread Safety","text":"<p>Thread Safety is the avoidance of race conditions, Which happens when multiple threads try to read and write to a shared resource causing unwanted behaviors. When using Parallel lua with roblox's DataModel. Roblox already has Thread Safety implemented into its Instances. Roblox has 4 Safety Levels: Unsafe, Read Parallel, Local Safe, and Safe. You can tell if a function/property has one of these tags by looking at the Roblox's API. If it has no tags then it defaults to UnSafe.</p> <p>Info</p>"},{"location":"Parallel%20luau/#unsafe","title":"UnSafe","text":"<p>Functions cannot be called and Properties cannot be read or written (modified) to</p>"},{"location":"Parallel%20luau/#read-parallel","title":"Read Parallel","text":"<p>Properties can be read but not written to</p>"},{"location":"Parallel%20luau/#local-safe","title":"Local Safe","text":"<p>If the instance was created was created under an actor then that actor can Read and Write to. Other actors can Read but not write. Functions can be called only in that actor.</p>"},{"location":"Parallel%20luau/#safe","title":"Safe","text":"<p>Functions can be called and Properties can be read and written to</p>"},{"location":"Parallel%20luau/#race-conditions","title":"Race Conditions","text":"<p>Race Conditions are when a thread reads or writes data when another thread is not finished computing that data, causing data to overlap or create unexpected behaviors. <pre><code>--Example\nlocal SharedTable = ...\nSharedTable.Value = 0\n--Let's say we are trying to add to a key called Value in the SharedTable\n--Each Thread will add 100 to the Value Key\n\n--//Parallel Thread\nfor i = 1,100 do\n    SharedTable.Value = SharedTable.Value + 1\nend\n\n--//Another Parallel Thread\nfor i = 1,100 do\n    SharedTable.Value = SharedTable.Value + 1\nend\n\n--//Outside of Parallel (After Parallel Threads ran)\nprint(SharedTable.Value) \n--&gt; This won't always print 200 as both Parallel are writing to The Value \n--at the same time which can overlap\n</code></pre></p> <p>Info</p> <p>The reason why it's happening can be shown in this diagram.</p> <p></p> <p>If you look at Value, each time a thread reads and writes it is reading and writing at the same time (this will not always happen). So it means that if both Threads run a for loop increasing Value by 100, the Value will not be 200 most of the time.</p>"},{"location":"Parallel%20luau/#avoiding-race-conditions","title":"Avoiding Race Conditions","text":"<p>When working with the DataModel roblox already implemented Thread Safety as shown above. Otherwise what you can do is combine the data in a Synchronized state so there is a lesser chance of data overlapping with each other or if you are working with a shared table use the functions increment() or update() to update data as it does an atomic update to the values.</p>"},{"location":"Parallel%20luau/#using-microprofiler","title":"Using Microprofiler","text":"<p>To open microprofiler on the client press ctrl-shift-f6. To pause press ctrl-P, If it opens an object viewer press ctrl-shift-f6 twice to reopen it and press ctrl-P again.</p>"},{"location":"Parallel%20luau/#using-the-debug-library","title":"Using the Debug Library","text":"<p>You can use profilebegin to help find how long your tasks takes. <pre><code>local function is_prime(n)\n    if n &lt;= 1 then\n        return false\n    end\n    for i = 2, math.sqrt(n) do\n        if n % i == 0 then\n            return false\n        end\n    end\n    return true\nend\nlocal function calculatePrimesFrom(from,to)\n    debug.profilebegin(\"primes\")\n    local primes = {}\n    for i = from,to do\n        table.insert(primes,is_prime(i))\n    end\n    debug.profileend()\n    return primes\nend\ncalculatePrimesFrom(0,10000)\n</code></pre> This will allow you to see how long primes takes to calculate.</p> <p></p> <p>which you can see here takes 1.313 ms</p> <p>Info</p> <p>Profiles will have a unique color depending on the name, so each profile will have the each color each time. To look for a profile look for colored boxes that stand out more.</p> <p></p> <p>But if your profiles last very short you can sort them by going to <code>Groups</code> and disabling [ALL] and enabling just Script and it will make it easier to spot</p> <p></p> <p>Some other groups I recommend enabling are <code>Lua</code> and <code>TaskQueue</code>. Lua will display the Scripts while TaskQueue will display stuff like the Sleep timer.</p>"},{"location":"Parallel%20luau/#accessing-microprofiler-for-server","title":"Accessing MicroProfiler for Server","text":"<p>To see the microprofiler of a server you would need to go to Developer Console (f9) and go to the <code>MicroProfiler</code> tab.</p> <p></p> <p>After that, I recommend setting <code>Frames Per Second</code> to 60 and <code>Seconds to Record</code> to 4 (maximum time). And to Record press <code>Start Recording</code>. After it is done Recording it will display a path in which it is saved. Follow that and you can view the data in a browser.</p>"},{"location":"Parallel%20luau/#why-multithread","title":"Why multithread","text":"<p>Multithreading can help increase performance by a lot. For example, if we try to calculate the primes from 0-100000 it will take the server</p> <p></p> <p>The tasks takes 26.920ms to calculate which is going to cause performance issues as each frame lasts 1/60 seconds which is ~16ms and since the task takes over 16ms the server will lag for 10ms.</p> <p>But if we split the tasks into 8 separate tasks</p> <p></p> <p>each task only takes about 4ms and since they are running in parallel to each other calculating 100000 primes only takes 4ms in total.</p>"},{"location":"Parallel%20luau/#utilizing-parallel-luau-properly","title":"Utilizing Parallel Luau properly","text":"<p>When using Parallel Luau it is recommended to separate tasks into smaller tasks. So let's say you have a task that takes 5ms to compute on a single thread. What you can do is split the tasks into 5 threads, Each chunk taking ~1 ms to compute, Saving 4 ms. Also when using Parallel Luau avoid yielding threads with wait or coroutine. Because when you use task.wait it will bring it out of parallel. And it is also recommended to Avoid long tasks as it will cause the main Thread (not to be confused with the Main script in the Image) to wait for that parallel task to finish. Show below with the <code>Sleep</code> timer.</p> <p></p> <p>What we could have done better here was to split the tasks into smaller tasks and use more Actors.</p> <p>Warning</p> <p>When using Parallel luau try not to split the tasks to into very small sections. If a simple task takes 1 ms on a single thread and you try to split it into 2 separate threads you could see a .4 ms decrease in time but if you split it into 4 threads then you could see it take longer than on a single thread as other factors can cause delay such as going into parallel and sending data across.</p>"},{"location":"Parallel%20luau/#how-many-actors-should-you-use","title":"How many actors should you use","text":"<p>On a roblox server, the amount of workers is determined by the maximum player count (source). While on the client it depends on the client's device. Workers are just how many threads can be utilized. Every time you run a parallel task the task will go to one of these workers. Roblox will try to balance which Worker should a task go to.</p> <p></p> <p>So when determining the number of Actors you want to use it is usually recommended to use more Actors than workers as roblox will balance the tasks between workers.</p> <p></p> <p>but avoid using too many or else other problems such as memory will show up.</p>"},{"location":"Parallel%20luau/#conclusion","title":"Conclusion","text":"<p>Parallel Luau is not an easy thing to explain and understand so don't worry if you don't understand. If you want to see the code I used for the Images above, make a copy of this place. If you want to learn more about Parallel Luau check out here.</p>"},{"location":"ProxyTables/","title":"ProxyTables","text":""},{"location":"ProxyTables/#pre-requisites","title":"Pre-requisites","text":"<p>Before reading this tutorial, you should know about metatables. An explanation of metatable exists in the Lua-Learning folder (not anymore).</p>"},{"location":"ProxyTables/#what-are-proxy-tables","title":"What are Proxy Tables?","text":"<p>proxy table are Tables that allow you to detect when a table is updated or changed using __newindex</p> Warning <p>Proxy tables are less efficient then normal metatables and this is caused by setting the __index to a function. If you want a more efficient method to detected Changes use Setters and Getter function instead. Ex. <pre><code>function Proxy:GetValue(key)\n    return self.RealData[key]\nend\nfunction Proxy:SetValue(key,value)\n    self.RealData[key] = value\n    print(\"Detected Change at\",key,\"new Value\",value)\nend\n</code></pre></p>"},{"location":"ProxyTables/#how-to-set-on-up","title":"How to set on up","text":"<p>what we want to do it use __newindex to reference the Real Data inside of the Proxy Table. </p> <p>We can set it up like this:</p> <pre><code>local Proxy = {}\n\nProxy.__newindex = function(self,key,value)\n    self.RealData[key] = value -- without this the key would need be set to the new value\n    print(\"Detected Change at\",key,\"new Value\",value)\nend\n\n\nfunction Proxy.new(DataTable)\n    return setmetatable({RealData = DataTable or {}},Proxy)\nend\n\nreturn Proxy\n</code></pre> <p>This is basically all you need for a proxy table to function </p> <pre><code>local Proxy = require(Path.To.Proxy.Module)\nlocal data ={\n    A = 1,\n    Hao = 2\n}\nlocal ProxyTable = Proxy.new(data)\n\nProxyTable.A = 2 --&gt; Detected Change at A new Value 2\nProxyTable.B = 3 --&gt; Detected Change at B new Value 3 \nProxyTable.Hao = nil --&gt; Detected Change at Hao new Value nil\n</code></pre>"},{"location":"ProxyTables/#features-you-can-add-to-your-proxy-table","title":"Features you can add to your proxy table","text":"<p>you can also add more features to the proxy table so that the proxy table can act like a normal table. here are some examples:</p> <p>adding the __index metamethod <pre><code>-- this will allow you to do ProxyTable[\"A\"] normally to get the data\nProxy.__index = function(self,key)\n    return self.RealData[key]\nend\n\n--Example Use Case\nprint(ProxyTable.ProxyTable.A) -- &gt; 2\nprint(ProxyTable.A) -- &gt; 2\n</code></pre></p> <p>adding the __iter metamethod <pre><code>-- this will allow the proxy table to be iterated by a for loop \nProxy.__iter = function(self)\n    return next,self.RealData -- similar to pairs(table)\nend\n\n--Example Use Case\nfor i,v in ProxyTable do\n    print(i,v) --&gt; A 2 | B 3     \nend\n</code></pre> adding a bindable event to use as a changed event <pre><code>-- this will allow the proxy table to be iterated by a for loop \nProxy.__newindex = function(self,key,value)\n    self.RealData[key] = value\n    self.Changed:Fire(key,value)\nend\n\nfunction Proxy.new(DataTable)\n    return setmetatable({RealData = DataTable or {},Changed = Instance.new(\"BindableEvent\")},Proxy)\nend\n\n--Example Use Case\nProxyTable.Changed.event:Connect(function(key,value)\n    print(\"table was modified\")\nend)\n</code></pre> Check out this link for more metamethods</p>"},{"location":"ProxyTables/#conclusion","title":"Conclusion","text":"<p>if you think you're going to use RealData as a key name you can name the key to something random so that when you do ProxyTable.RealData={} it wouldn't override your real data with an empty table. Anyways thats it for this tutorial, hope this helps </p>"},{"location":"Vector3%20Methods/","title":"Vector3 Methods","text":""},{"location":"Vector3%20Methods/#pre-requisites","title":"Pre-requisites","text":"<p>Before reading this tutorial, you should know about vector3s. An explanation of vector3 exists in the Lua-Learning folder (not anymore). Or check out the Roblox docs.</p>"},{"location":"Vector3%20Methods/#info","title":"Info","text":"<p>In this tutorial, I will teach you what each Vector3 method does and some of its use cases.</p>"},{"location":"Vector3%20Methods/#dotother-vector3-vector3","title":"Dot(other: Vector3): Vector3","text":"<p>This method returns the scalar dot product between two vectors. The scalar dot formula is  <pre><code>scalarDot = (x1 * x2) + (y1 * y2) + (z1 * z2)\n</code></pre></p>"},{"location":"Vector3%20Methods/#how-is-it-useful","title":"How is it useful?","text":"<p>Take this script for an example <pre><code>local part1 = script.Parent.Part1 -- blue part\nlocal part2 = script.Parent.Part2 -- green part\n\nlocal dirArrow = script.Parent.Dir  -- blue/yellow arrow\n\nlocal function Update()\n    -- this will be visualized by the light blue/yellow arrow\n    local direction = (part2.Position - part1.Position).Unit\n\n    -- this will be visualized by the black arrow\n    local lv = part1.CFrame.lookVector \n    local dotProduct = direction:Dot(lv)\n\n    print(\"Dot: \"..dotProduct)\n\n    if dotProduct &gt; 0 then\n        -- if part 1 can see part 2\n        --turn blue\n        dirArrow.Color = Color3.new(0.0352941, 0.537255, 0.811765)\n    else\n        -- if part 1 cannot  see part 2\n        --turn yellow\n        dirArrow.Color = Color3.new(1, 1, 0)\n    end\n    --makes the direction arrow point toward the direction\n    dirArrow.CFrame = CFrame.lookAt(part1.Position + Vector3.new(0,.5,0), part1.Position + Vector3.new(0, .5, 0) + direction)\n\nend\n\n\nUpdate()\npart2.Changed:Connect(Update)\n</code></pre> What this script does is if the green part is in a 180-degree view of the blue part, then make the arrow blue. Else make the arrow yellow, which you can see from the gif below. It also prints a value between -1 and 1 if you look at the output on the right side.</p> <p></p> <p>This can be very useful in some use cases, such as checking if you are in the field of view of an NPC.</p> <p>But what if I want the NPC's FOV to be narrower?</p> <p>What you can do is replace this line</p> <p><pre><code>if dotProduct &gt; 0 then\n</code></pre> With <pre><code>if dotProduct &gt; math.cos(math.rad(MAX_ANGLE)) then\n</code></pre> </p> <p>Why the math.cos you may ask?   </p> <p>Take this image as a reference </p> <p></p> <p>The bold black arrow is the lookVector. The blue arrows/rays create the cone shape, whereas the pink curve is the range in which the green part is considered inside, and the red line is the red part in the gif.</p> <p>Info</p> <p>A reminder to everyone that forgot trigonometry, cosine is the x value, and sine is the y value, but in this case, we only care about the x value, which is cosine.</p>"},{"location":"Vector3%20Methods/#angleother-vector3-axis-vector3-nil-number","title":"Angle(other: Vector3, axis: Vector3 | nil ): number","text":"<p>This method returns the angle in radians between two vector3s. If an axis is provided, it will return an angle around the specified axis (default is Vector3.zAxis)</p>"},{"location":"Vector3%20Methods/#example","title":"Example","text":"<p>(without providing axis) <pre><code>local part1 = script.Parent.Part1 -- blue part\nlocal part2 = script.Parent.Part2 -- green part\n\nlocal dirArrow = script.Parent.Dir  -- blue/yellow arrow\n\n\nlocal function Update()\n    -- this will be visualized by the light blue/yellow arrow\n    local direction = (part2.Position - part1.Position).Unit\n\n    -- this will be visualized by the black arrow \n    local lv = part1.CFrame.lookVector \n    local Angle = direction:Angle(lv)\n\n    print(\"Angle: \"..math.deg(Angle))\n\n    --makes the direction arrow point toward the direction\n    dirArrow.CFrame = CFrame.lookAt(part1.Position + Vector3.new(0, .5, 0), part1.Position + Vector3.new(0, .5, 0) + direction)\n\nend\n\n\nUpdate()\npart2.Changed:Connect(Update)\n</code></pre> </p> <p>(with axis argument = Vector3.xAxis) </p> <p>Info</p> <p>You can play around more in the test place that I will link at the bottom.</p>"},{"location":"Vector3%20Methods/#fuzzyeqother-vector3-epsilon-number-boolean","title":"FuzzyEq(other: Vector3, epsilon: number): boolean","text":"<p>This method returns true if the given vector3 is within the current vector3 by the epsilon.</p>"},{"location":"Vector3%20Methods/#how-it-works","title":"How it works","text":"<p>Source <pre><code>function fuzzyEq(a, b, epsilon)\n    return a == b or math.abs(a - b) &lt;= (math.abs(a) + 1) * epsilon\nend\n\nfunction fuzzyEqVec(v1, v2, epsilon)\n    for _, axis in ipairs({\"X\", \"Y\", \"Z\"}) do\n        if not fuzzyEq(v1[axis], v2[axis], epsilon) then\n            return false\n        end\n    end\n\n    return true\nend\n</code></pre></p>"},{"location":"Vector3%20Methods/#use-cases","title":"Use cases","text":"<p>You can use it to detect when the player stopped moving using their MoveDirection <pre><code>local humanoid: Humanoid = script.Parent.Humanoid\n\nhumanoid:GetPropertyChangedSignal(\"MoveDirection\"):Connect(function()\n    --if it is close by .001 \n    if humanoid.MoveDirection:FuzzyEq(Vector3.zero, .001) then\n        print(\"Player Stopped Moving\")\n    end\n\nend)\n</code></pre></p>"},{"location":"Vector3%20Methods/#crossother-vector3-vector3","title":"Cross(other: Vector3): Vector3","text":"<p>This method returns the cross product of the two vectors </p>"},{"location":"Vector3%20Methods/#example_1","title":"Example","text":"<p>The blue arrow is the the direction(self), the yellow arrow is the cross(result), the black arrow is the lookVector(other) <pre><code>local part1 = script.Parent.Part1 -- blue part\nlocal part2 = script.Parent.Part2 -- green part\n\nlocal dirArrow = script.Parent.Dir  -- blue arrow\nlocal crossArrow = script.Parent.Cross  -- yellow arrow\n\nlocal function Update()\n    -- this will be visualized by the light blue arrow\n    local direction = (part2.Position - part1.Position).Unit\n    -- this will be visualized by the black arrow \n    local lv = part1.CFrame.lookVector \n    local Cross = direction:Cross(lv)\n    print(\"Cross:\", Cross)\n\n    --makes the direction arrow point toward the direction\n    dirArrow.CFrame = CFrame.lookAt(part1.Position + Vector3.new(0, .5, 0), part1.Position+Vector3.new(0, .5, 0) + direction)\n    crossArrow.CFrame = CFrame.lookAt(part1.Position + Vector3.new(0, .5, 0), part1.Position+Vector3.new(0, .5, 0) + Cross)\n\nend\n\n\nUpdate()\npart2.Changed:Connect(Update)\n</code></pre> </p>"},{"location":"Vector3%20Methods/#lerpgoal-vector3-alpha-number-vector3","title":"Lerp(goal: Vector3, alpha: number): Vector3","text":"<p>This method returns a Vector3 that is interpolated to the goal by the alpha or percent.</p>"},{"location":"Vector3%20Methods/#how-it-works_1","title":"How it works","text":"<pre><code>function Lerp(start,goal,alpha)\n    return start + (goal - start) * alpha\nend\n\nfunction Vector3Lerp(start,goal,alpha)\n    return Vector3.new(\n        Lerp(start.X, goal.X, alpha),   \n        Lerp(start.Y, goal.Y, alpha),\n        Lerp(start.Z, goal.Z, alpha),\n    )\nend\n</code></pre> Info <p>This also works and is more efficient then the other the way. Because Vector3 has __sub and __add metamethods <pre><code>function Vector3Lerp(start,goal,alpha)\n    return Lerp(start,goal,alpha)\nend\n</code></pre></p>"},{"location":"Vector3%20Methods/#use-case","title":"Use Case","text":"<p>You can use it to make parts move smoothly  <pre><code>local start = script.Parent.Part1 -- blue part\nlocal end = script.Parent.Part2 -- green part\nlocal move = script.Parent.Move -- grey part\n\nwhile true do\n    -- lerp forward\n    for i = 0, 1, .01 do-- go from 0-1\n        task.wait()\n        Move.Position = Start.Position:Lerp(End.Position,i)\n    end\n\n    task.wait(2)\n    -- lerp back\n    for i = 0, 1, .01 do -- go from 0-1\n        task.wait()\n        Move.Position = End.Position:Lerp(Start.Position, i)\n    end\n    task.wait(2)\n    --repeat \nend\n</code></pre> (gif might be a bit laggy)</p> <p></p> <p>Difference between Lerp and TweenService</p> <p>Tween service is a roblox Service that only works on Instances while with Lerping you don't need instances and all you need is just two values.</p>"},{"location":"Vector3%20Methods/#minvector-vector3-vector3","title":"Min(vector: Vector3): Vector3","text":"<p>This method returns a Vector3 with each component being the lowest value for both Vectors <pre><code>local vector1 = Vector3.new(5,2,7)\nlocal vector2 = Vector3.new(1,5,3)\n\nprint(\"Min: \", vector2:Min(vector1)) -- \"Min: 1,2,3\"\n</code></pre></p>"},{"location":"Vector3%20Methods/#maxvector-vector3-vector3","title":"Max(vector: Vector3): Vector3","text":"<p>This method returns a Vector3 with each component as the highest for both Vectors <pre><code>local vector1 = Vector3.new(5,2,7)\nlocal vector2 = Vector3.new(1,5,3)\n\nprint(\"Max: \", vector2:Min(vector1)) -- \"Max: 5,5,7\"\n</code></pre></p>"},{"location":"Vector3%20Methods/#conclusion","title":"Conclusion","text":"<p>I hope this helps you understand these methods better and what they do. The link to the example will be here. To view the code, simply make a copy of the game by pressing the 3 dots on the top right and clicking edit. Once you are in, you can move the green parts around to see different results. Anyways bye! (It is currently 4:18 AM, I spent 3 hours on this)</p>"}]}